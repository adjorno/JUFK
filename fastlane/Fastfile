default_platform(:android)

# Helper to extract version from git tag or branch
def get_version_name
  # Try to get version from git tag (e.g., v1.2.3 -> 1.2.3)
  tag = `git describe --tags --abbrev=0 2>/dev/null`.strip
  if tag =~ /^v?(\d+\.\d+\.\d+)/
    return $1
  end

  # Try to get from branch name (e.g., release/1.2.3 -> 1.2.3)
  branch = `git rev-parse --abbrev-ref HEAD`.strip
  if branch =~ /(\d+\.\d+\.\d+)/
    return $1
  end

  # Fallback
  "1.0.0"
end

# Android lanes
platform :android do

  def fetch_next_play_store_version_code
    tracks = %w[internal alpha beta production]
    all_version_codes = []

    tracks.each do |track|
      begin
        codes = google_play_track_version_codes(
          track: track,
          json_key_data: ENV["PLAY_SERVICE_ACCOUNT_JSON"]
        )
        all_version_codes.concat(codes) if codes
      rescue => e
        UI.message("Skipping track #{track}: #{e.message}")
      end
    end

    (all_version_codes.max || 0) + 1
  end

  desc "Build release AAB"
  lane :build do |options|
    version_name = options[:version] || get_version_name
    gradle_properties = options[:gradle_properties] || {}

    version_code = options[:version_code]
    unless version_code
      begin
        version_code = fetch_next_play_store_version_code
      rescue => e
        UI.message("Failed to get version code from Play Store, defaulting to 1. Error: #{e.message}")
        version_code = 1
      end
    end

    UI.message("Building version #{version_name} (#{version_code})")

    gradle(
      task: "bundle",
      build_type: "Release",
      project_dir: ".",
      gradle_path: "./gradlew",
      properties: gradle_properties.merge({
        "android.injected.signing.store.file" => ENV["KEYSTORE_PATH"],
        "android.injected.signing.store.password" => ENV["KEYSTORE_PASSWORD"],
        "android.injected.signing.key.alias" => ENV["KEY_ALIAS"],
        "android.injected.signing.key.password" => ENV["KEY_PASSWORD"],
        "VERSION_NAME" => version_name,
        "VERSION_CODE" => version_code.to_s
      })
    )

    lane_context[:VERSION_NAME] = version_name
    lane_context[:VERSION_CODE] = version_code
  end

  desc "Deploy to a specific Play Store track"
  private_lane :deploy_to_track do |options|
    build(version: options[:version])
    upload_to_play_store(
      track: options[:track],
      aab: "androidApp/build/outputs/bundle/release/androidApp-release.aab",
      json_key_data: ENV["PLAY_SERVICE_ACCOUNT_JSON"]
    )
  end

  desc "Deploy to Play Store internal track"
  lane :internal do |options|
    deploy_to_track(track: "internal", version: options[:version])
  end

  desc "Deploy to Play Store alpha track"
  lane :alpha do |options|
    deploy_to_track(track: "alpha", version: options[:version])
  end

  desc "Deploy to Play Store beta track"
  lane :beta do |options|
    deploy_to_track(track: "beta", version: options[:version])
  end

  desc "Deploy to Play Store production"
  lane :production do |options|
    deploy_to_track(track: "production", version: options[:version])
  end
end

# iOS lanes
platform :ios do
  desc "Build iOS app"
  lane :build do |options|
    version_name = options[:version] || get_version_name
    match = version_name.match(/(\d+\.\d+\.\d+)/)
    sanitized_version = match ? match[1] : "1.0.0"

    # Get next build number from TestFlight
    build_number = options[:build_number]
    unless build_number
      begin
        build_number = latest_testflight_build_number(
          api_key_path: ENV["APP_STORE_CONNECT_API_KEY_PATH"]
        ) + 1
      rescue => e
        UI.message("Failed to get build number from TestFlight, defaulting to 1. Error: #{e.message}")
        build_number = 1
      end
    end

    UI.message("Building version #{version_name} (#{build_number})")

    increment_version_number(
      version_number: sanitized_version,
      xcodeproj: "iosApp/iosApp.xcodeproj"
    )

    increment_build_number(
      build_number: build_number,
      xcodeproj: "iosApp/iosApp.xcodeproj"
    )

    provisioning_profile = ENV.fetch("PROVISIONING_PROFILE_SPECIFIER")

    ENV["VERSION_NAME"] = version_name

    build_app(
      project: "iosApp/iosApp.xcodeproj",
      scheme: "iosApp",
      output_directory: "iosApp/build",
      output_name: "JUFK.ipa",
      export_method: "app-store",
      xcargs: [
        "DEVELOPMENT_TEAM=#{ENV.fetch('DEVELOPMENT_TEAM')}",
        "CODE_SIGN_STYLE=Manual",
        "CODE_SIGN_IDENTITY='Apple Distribution'",
        "PROVISIONING_PROFILE_SPECIFIER='#{provisioning_profile}'"
      ].join(" "),
      export_options: {
        signingStyle: "manual",
        provisioningProfiles: {
          CredentialsManager::AppfileConfig.try_fetch_value(:app_identifier) => provisioning_profile
        }
      }
    )

    lane_context[:VERSION_NAME] = version_name
    lane_context[:BUILD_NUMBER] = build_number
  end

  desc "Deploy to TestFlight"
  lane :testflight_upload do |options|
    build(version: options[:version])
    upload_to_testflight(
      api_key_path: ENV["APP_STORE_CONNECT_API_KEY_PATH"],
      skip_waiting_for_build_processing: true
    )
  end

  desc "Deploy to App Store"
  lane :release do |options|
    build(version: options[:version])
    upload_to_app_store(
      api_key_path: ENV["APP_STORE_CONNECT_API_KEY_PATH"],
      skip_screenshots: true,
      skip_metadata: false,
      submit_for_review: false
    )
  end
end
