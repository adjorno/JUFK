default_platform(:android)

# Helper to extract version from git tag or branch
def get_version_name
  # Try to get version from git tag (e.g., v1.2.3 -> 1.2.3)
  tag = `git describe --tags --abbrev=0 2>/dev/null`.strip
  if tag =~ /^v?(\d+\.\d+\.\d+)/
    return $1
  end

  # Try to get from branch name (e.g., release/1.2.3 -> 1.2.3)
  branch = `git rev-parse --abbrev-ref HEAD`.strip
  if branch =~ /(\d+\.\d+\.\d+)/
    return $1
  end

  # Fallback
  "1.0.0"
end

# Android lanes
platform :android do
  desc "Build release AAB"
  lane :build do |options|
    version_name = options[:version] || get_version_name

    # Get next version code from Play Store
    version_code = options[:version_code]
    unless version_code
      begin
        version_codes = google_play_track_version_codes(
          track: "internal",
          json_key_data: ENV["PLAY_SERVICE_ACCOUNT_JSON"]
        )
        version_code = (version_codes.max || 0) + 1
      rescue => e
        UI.message("Failed to get version code from Play Store, defaulting to 1. Error: #{e.message}")
        version_code = 1
      end
    end

    UI.message("Building version #{version_name} (#{version_code})")

    gradle(
      task: "bundle",
      build_type: "Release",
      project_dir: ".",
      gradle_path: "./gradlew",
      properties: {
        "android.injected.signing.store.file" => ENV["KEYSTORE_PATH"],
        "android.injected.signing.store.password" => ENV["KEYSTORE_PASSWORD"],
        "android.injected.signing.key.alias" => ENV["KEY_ALIAS"],
        "android.injected.signing.key.password" => ENV["KEY_PASSWORD"],
        "VERSION_NAME" => version_name,
        "VERSION_CODE" => version_code.to_s
      }
    )

    lane_context[:VERSION_NAME] = version_name
    lane_context[:VERSION_CODE] = version_code
  end

  desc "Deploy to a specific Play Store track"
  private_lane :deploy_to_track do |options|
    build
    upload_to_play_store(
      track: options[:track],
      aab: "androidApp/build/outputs/bundle/release/androidApp-release.aab",
      json_key_data: ENV["PLAY_SERVICE_ACCOUNT_JSON"]
    )
  end

  desc "Deploy to Play Store internal track"
  lane :internal do
    deploy_to_track(track: "internal")
  end

  desc "Deploy to Play Store alpha track"
  lane :alpha do
    deploy_to_track(track: "alpha")
  end

  desc "Deploy to Play Store beta track"
  lane :beta do
    deploy_to_track(track: "beta")
  end

  desc "Deploy to Play Store production"
  lane :production do
    deploy_to_track(track: "production")
  end
end

# iOS lanes
platform :ios do
  desc "Build iOS app"
  lane :build do |options|
    version_name = options[:version] || get_version_name

    # Get next build number from TestFlight
    build_number = options[:build_number]
    unless build_number
      begin
        build_number = latest_testflight_build_number(
          api_key_path: ENV["APP_STORE_CONNECT_API_KEY_PATH"]
        ) + 1
      rescue => e
        UI.message("Failed to get build number from TestFlight, defaulting to 1. Error: #{e.message}")
        build_number = 1
      end
    end

    UI.message("Building version #{version_name} (#{build_number})")

    increment_version_number(
      version_number: version_name,
      xcodeproj: "iosApp/iosApp.xcodeproj"
    )

    increment_build_number(
      build_number: build_number,
      xcodeproj: "iosApp/iosApp.xcodeproj"
    )

    provisioning_profile = ENV.fetch("PROVISIONING_PROFILE_SPECIFIER")

    build_app(
      project: "iosApp/iosApp.xcodeproj",
      scheme: "iosApp",
      output_directory: "iosApp/build",
      output_name: "JUFK.ipa",
      export_method: "app-store",
      xcargs: [
        "DEVELOPMENT_TEAM=#{ENV.fetch('DEVELOPMENT_TEAM')}",
        "CODE_SIGN_STYLE=Manual",
        "CODE_SIGN_IDENTITY='Apple Distribution'",
        "PROVISIONING_PROFILE_SPECIFIER='#{provisioning_profile}'"
      ].join(" "),
      export_options: {
        signingStyle: "manual",
        provisioningProfiles: {
          CredentialsManager::AppfileConfig.try_fetch_value(:app_identifier) => provisioning_profile
        }
      }
    )

    lane_context[:VERSION_NAME] = version_name
    lane_context[:BUILD_NUMBER] = build_number
  end

  desc "Deploy to TestFlight"
  lane :testflight_upload do
    build
    upload_to_testflight(
      api_key_path: ENV["APP_STORE_CONNECT_API_KEY_PATH"],
      skip_waiting_for_build_processing: true
    )
  end

  desc "Deploy to App Store"
  lane :release do
    build
    upload_to_app_store(
      api_key_path: ENV["APP_STORE_CONNECT_API_KEY_PATH"],
      skip_screenshots: true,
      skip_metadata: false,
      submit_for_review: false
    )
  end
end

# macOS lanes
platform :mac do
  desc "Build macOS app for App Store"
  lane :build do |options|
    version_name = options[:version] || get_version_name
    UI.message("Building macOS version #{version_name}")

    # 1. Build .app with Gradle
    java_home = ENV['JAVA_HOME'] || '/Users/adjorno/Library/Java/JavaVirtualMachines/jbr-17.0.14/Contents/Home'
    sh("cd .. && JAVA_HOME=#{java_home} ./gradlew :composeApp:packageReleaseDistributionForCurrentOS -PappVersion=#{version_name}")

    # 2. Sign .app with Mac App Distribution certificate
    app_path = "../composeApp/build/compose/binaries/main-release/app/JUFK.app"
    sh("codesign --deep --force --options runtime --entitlements ../composeApp/entitlements.plist --sign '#{ENV.fetch('MAC_APP_SIGN_IDENTITY')}' #{app_path}")

    # 3. Create and sign PKG with Mac Installer Distribution certificate
    pkg_path = "../JUFK-#{version_name}.pkg"
    sh("productbuild --component #{app_path} /Applications --sign '#{ENV.fetch('MAC_INSTALLER_SIGN_IDENTITY')}' #{pkg_path}")

    # 4. Verify signatures
    sh("codesign --verify --verbose #{app_path}")
    sh("pkgutil --check-signature #{pkg_path}")

    lane_context[:VERSION_NAME] = version_name
    lane_context[:PKG_PATH] = pkg_path
  end

  desc "Upload to TestFlight"
  lane :testflight_upload do
    build
    upload_to_testflight(
      api_key_path: ENV["APP_STORE_CONNECT_API_KEY_PATH"],
      skip_waiting_for_build_processing: true,
      platform: "osx",
      pkg: lane_context[:PKG_PATH]
    )
  end

  desc "Upload to App Store"
  lane :release do
    build
    deliver(
      api_key_path: ENV["APP_STORE_CONNECT_API_KEY_PATH"],
      skip_screenshots: true,
      skip_metadata: false,
      submit_for_review: false,
      platform: "osx",
      pkg: lane_context[:PKG_PATH]
    )
  end
end
